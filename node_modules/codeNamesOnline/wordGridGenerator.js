'use strict';
//==============================================================================
//  Modules
//==============================================================================

var databaseManager = require('codeNamesOnline/database/databaseManager');
var wordType        = require('codeNamesOnline/constants/wordType');
var async           = require('async');

//==============================================================================
//  Public functions
//==============================================================================

module.exports.generateWordGrid = function (callback) {

	async.waterfall([
		getWordCount,
		getOffsets,
		getWords,
		buildGrid
	], function (error, wordGrid) {
		if (error) {
			return callback(error);
		}
		else {
			return callback(null, wordGrid);
		}
	});

};

//==============================================================================
//  Private functions
//==============================================================================

// Gets how many words ar available from the database
function getWordCount (callback) {

	databaseManager
	.GetQueryBuilder()('words').count('word')
	.asCallback(function (error, row) {
		if (error) {
			return callback(error);
		}
		else {
			return callback(null, row[0]['count(`word`)']);
		}
	});
}

// Get 25 random offsets based on word count
// All offsets will be unique
function getOffsets (wordCount, callback) {

	// Get random offsets to query with
	var offsets = [];
	for (var i = 0; i < 25; i++) {
		var offset;
		do {
			offset = Math.floor(Math.random() * (wordCount - 1));
		} while(isDuplicateOffset(offset));
		offsets.push(offset);
	}

	function isDuplicateOffset (offset) {
		for (var i = 0; i < offsets.length; i++) {
			if (offsets[i] === offset) {
				return true;
			}
		}
		return false;
	}

	return callback(null, offsets);
}

// Gets 25 words from the database using an array of offsets
function getWords (offsets, callback) {

	async.map(offsets,
	function (offset, callback) {
		databaseManager
		.GetQueryBuilder()
		.select('word')
		.from('words')
		.limit(1)
		.offset(offset)
		.asCallback(function (error, row) {
			if (error) {
				return callback(error);
			}
			else {
				return callback(null, row[0].word);
			}
		});
	}, 
	function (error, words) {
		if (error) {
			return callback(error);
		}
		else {
			return callback(null, words);
		}
	});
}

// Arrange words into a 5x5 grid,
// assign words a type (blue|red|no team|kill word),
// and set chosen to false
function buildGrid (words, callback) {

	var wordGrid = {};

	if (words.length < 25) {
		return callback(new Error('Not enough words to fill 5x5 grid'));
	}

	// Randomly choose a team to go first (first team needs 9 words)
	var blueCount;
	var redCount;
	var randomIndex = Math.floor(Math.random()) + 1;
	if (randomIndex === 1) {
		redCount = 9;
		blueCount = 8;
		wordGrid.startTeam = 'red';
	}
	else {
		redCount = 8;
		blueCount = 9;
		wordGrid.startTeam = 'blue';
	}

	var types = [
		{ name : wordType.BLUE_TEAM, count : blueCount },
		{ name : wordType.RED_TEAM,  count : redCount },
		{ name : wordType.NO_TEAM,   count : 7 },
		{ name : wordType.KILL_WORD, count : 1 }
	];

	wordGrid.grid = [];

	for (var x = 0; x < 5; x++) {
		for (var y = 0; y < 5; y++) {
			if (wordGrid.grid[x] === undefined) { wordGrid.grid[x] = []; }
			var typeIndex = Math.floor(Math.random() * types.length);
			wordGrid.grid[x][y] = {
				word   : words.pop(),
				type   : types[typeIndex].name,
				chosen : false
			};
			types[typeIndex].count--;
			if (types[typeIndex].count === 0) {
				types.splice(typeIndex, 1);
			}
		}
	}

	return callback(null, wordGrid);
}








